11 / 10 / 2019:
Todo:
- Logic implementation:
  - The cues will all break down to a single vector:
    - This means that it's probably easiest just to have the beetle
      always travel in that direction.
    - Whenever the combined cue-vector changes the beetle's direction changes
  - Current solution is to have the beetle go towards its combined cue vector.
    Creating a new beetle should allow you to track the change. This is a bad solution.
Notes:
- Yesterday spent trying to get some slides together, no code written
- Congrats, you can add vectors together and do first year maths. Now you need to be able
  to average them and project the response onto the ground


09 / 10 / 2019:
Todo:
- Logic for behaviour
  - This can go in the beetle class. Pass it a list of cues and a strategy, it
    does the rest and updates its direction appropriately (or define a new vector
    with something like self.__newdirection)

Done:
- Add beetle entity and directional vector(s)?
- Input at least for the cues required imminently is done using YAML. Makes
  deserialisation reasonably straightforward and the file is human-friendly too.
- Set default view to be a little more helpful. Still having doubts over visualisation

Notes:
- Hmm, I know where behaviour should go, but I don't know quite how to break it down.
  - I had two strategies in mind. Winner-take-all and vector summation. The former is
    unrealistic I think, but easy enough to implement.
  - Know that if the beetle receives even-strength cues (e.g. two light sources) then
    it can't orient.
  - Could simply take the azimuthal difference of the resultant cue vector (by whatever
    strategy) from the beetle's vector (unit vector along x-axis) as the bearing.
08 / 10 / 2019:
Todo:
Done:
(Did nothing this day, working on write-up)


07 / 10 / 2019:
Todo:
- (semi-done) Add debug view of each cue's actual vector.

Done:
- Rewrite Cues to use elevation and azimuth as per convention
  - Should entities use this convention too? Decided not as entities don't really
    need to be configurable in the same way
- Add strength to Cues but keep it separate from the underlying Vec3
- Added a Wind cue along with code to draw it in the plot. I'm not happy with how this
  all looks but it's more important that it's functional at the moment.

Notes:
- The angular stuff could be solved by leaving Vec3 as it should be, then setting cues
  to use elevation and azimuth according to the conventions used by the paper.
- For strength, could a Cue always be a unit vector, then the magnitude parameter is applied
  to the underlying vector for all calculations.
- I think the separation is between world descriptions and geometric descriptions.
- Realised I'm dumb and I used the physics convention for naming in spherical coordinate systems. This cost me
  40 minutes of debugging.
- I should add exceptions for the azimuthal and elevation positions. Azimuth shouldn't go past +-180 (and they should
  be equivalent). Elevation shouldn't go past 90 or be less than 0. I guess internally having stupid azimuths shouldn't
  cause a difference in behaviour but it makes usage easier.
- Wind.add_to_world will require some messing around. In the world i think this should
  be a vector pointing inward to the edge of the world, what about internally? I think
  I'm conflating drawing on the world and internal representation again. No this one is
  a bit more tricky. If the wind direction is 180deg then the position should be zero surely?

  I can also just say the wind has an azimuthal position and the direction is always
  pointing into the centre. I.e. the position of the cue determines the direction. But again
  the point of confusion is that the vector which determines the position is pointing in
  the opposite direction to that which should determine the cue direction; I'm not sure
  this really matters now that I think about it.

- I think it would also be good to add a debug visualisation step which
  shows the actual vectors for each cue.
- Feeling stressed but the visualisation should all be in place and the basic geometric
  stuff should be straightforward.

04 / 10 / 2019:

Notes:
- Have basic world representation stuff in place
- Angles are messed up though. Spherical coordinates work perfectly but theta isn't
  really elevation, it's pi/2 - elevation.
  - Not really sure how to deal with this as converting back and forth could prove
    a problem.
- Also ran into problems with the representation of cues versus their strength.
  Internally, the strength is the vector magnitude but for visualisation the
  magnitude must be a unit vector (at least for lights).

- MUST REMEMBER TO PROVIDE SETUP INSTRUCTIONS, this thing will be useless if
  it only runs on my machine.

Suggestions from meeting with Barbara:
- Doing things using basic vector geometry seems to be appropriate.
- Show the response for all cues present and then a combined response. This might
  be a much more practical way of solving the "strength" problem. We can see what would happen
  if all cues were weighted equally of if each was present alone.
- Add some noise to the signal, I understand the value in this but not really how to do it.
  The idea is to generate a distribution of responses which could model a population rather
  than generating a mean response. This was suggested as an additional requirement and not
  something to worry about immediately.

